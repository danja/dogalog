<h1>Dogalog Manual</h1>
<h2>What is this?</h2>
<p>A tiny, Prolog-ish livecoding playground in the browser. You write facts and rules; the engine queries <code>event(Voice, Pitch, Vel, T)</code> every step and plays matching sounds.</p>
<h2>Getting started</h2>
<ol>
<li>Open the app (GitHub Pages link in the README).</li>
<li>Click once on the page, then press <strong>Start</strong> to unlock audio.</li>
<li>Edit rules in the editor â€” changes load automatically as you type.</li>
<li>Use <strong>BPM</strong>, <strong>Swing</strong>, and <strong>Lookahead</strong> sliders to tweak feel and timing.</li>
</ol>
<h2>Core syntax</h2>
<ul>
<li>Facts end with <code>.</code>: <code>kick(t0).</code></li>
<li>Rules: <code>head :- goal1, goal2.</code></li>
<li>Variables start uppercase or <code>_</code>; atoms start lowercase.</li>
<li>Lists: <code>[a, b, c]</code>.</li>
<li>Comments: <code>% comment text</code>.</li>
</ul>
<h2>Built-ins (music + constraints)</h2>
<ul>
<li>Rhythm grids: <code>beat(T, N)</code>, <code>phase(T, N, K)</code>, <code>every(T, Step)</code></li>
<li>Probability: <code>prob(P)</code></li>
<li>Lists/choices: <code>choose(List, X)</code>, <code>pick(List, X)</code>, <code>cycle(List, X)</code>, <code>range(Start, End, Step, X)</code></li>
<li>Random: <code>rand(Min, Max, X)</code>, <code>randint(Min, Max, X)</code></li>
<li>Math/relations: <code>eq(A,B)</code>, <code>add(A,B,C)</code>, <code>lt(A,B)</code>, <code>gt(A,B)</code></li>
<li>Constraints: <code>within(T, Start, End)</code>, <code>distinct(List)</code>, <code>cooldown(Now, Last, Gap)</code></li>
<li>Euclidean: <code>euc(T, K, N, B, R)</code></li>
<li>Pitch helpers: <code>scale(Root, Mode, Degree, Oct, Midi)</code>, <code>chord(Root, Quality, Oct, Midi)</code>, <code>transpose(Note, Offset, Out)</code>, <code>rotate(List, Shift, OutList)</code></li>
</ul>
<h2>Instruments (voices)</h2>
<ul>
<li><code>kick</code>, <code>snare</code>, <code>hat</code>, <code>clap</code>, <code>noise</code> (drums/noise; ignore Pitch)</li>
<li><code>sine</code>, <code>square</code>, <code>triangle</code> (monosynths; Pitch is MIDI)</li>
</ul>
<h2>Examples</h2>
<pre><code class="language-prolog">% Drums
kik(T) :- euc(T, 4, 16, 4, 0).
snr(T) :- euc(T, 2, 16, 4, 4).
hat(T) :- euc(T,11, 16, 4, 0).

event(kick, 36, 0.95, T) :- kik(T).
event(snare, 38, 0.85, T) :- snr(T).
event(hat, 42, 0.25, T) :- hat(T).

% Bass: choose notes every half beat
bass(T, N) :- every(T,0.5), pick([40,43,47,48], N).
event(sine, N, 0.55, T) :- bass(T, N).

% Lead using scale degrees
lead(T, N) :- every(T,0.25), scale(60, ionian, 1, 0, N).
lead(T, N) :- every(T,0.25), scale(60, ionian, 3, 0, N).
lead(T, N) :- every(T,0.25), scale(60, ionian, 5, 0, N).
event(sine, N, 0.4, T) :- lead(T, N).

% Recursive loop over time (bounded)
loop_hats(T, End) :-
  T =&lt; End,
  event(hat, 42, 0.25, T),
  add(T, 0.125, T1),
  loop_hats(T1, End).

start_loop(T0) :-
  event(kick, 36, 0.95, T0),
  add(T0, 0.125, Tstart),
  add(T0, 2.0, Tend),
  loop_hats(Tstart, Tend).

% Recursive walk through a list (motif)
play_seq(T, Step, [N|Ns]) :-
  event(sine, N, 0.5, T),
  add(T, Step, T1),
  play_seq(T1, Step, Ns).
play_seq(_, _, []).
motif(T) :- play_seq(T, 0.25, [60,62,65,67]).
</code></pre>
<h2>Tips</h2>
<ul>
<li>Every rule ends with <code>.</code></li>
<li>Combine deterministic grids (<code>beat/phase/every</code>) with <code>prob</code> for variation.</li>
<li><code>cycle</code> for motifs, <code>pick/rand</code> for surprise, <code>euc</code> for quick grooves.</li>
<li>If timing is off, reduce Lookahead; add Swing for feel.</li>
</ul>
<h2>Dogalog Language Reference</h2>
<ul>
<li><strong>Programs</strong>: A program is a list of clauses ending with <code>.</code>. Clauses are either facts (<code>drum(kick).</code>) or rules (<code>head :- goal1, goal2.</code>).</li>
<li><strong>Terms</strong>: atoms (<code>kick</code>), numbers (<code>42</code>, <code>3.14</code>), variables (<code>X</code>, <code>_Foo</code>), lists (<code>[a, b, c]</code>), compounds (<code>event(kick, 36, 0.8, T)</code>), and arithmetic expressions (<code>(A + 3) * 0.5</code>).</li>
<li><strong>Variables</strong>: Uppercase or <code>_</code> start a variable; <code>_</code> is anonymous and fresh each time. Variables are renamed per rule application.</li>
<li><strong>Top goal</strong>: The engine repeatedly queries <code>event(Voice, Pitch, Vel, T)</code>. Your rules should ultimately derive that predicate to make sound.</li>
<li><strong>Conjunction</strong>: <code>,</code> means logical AND and is evaluated left-to-right with backtracking.</li>
<li><strong>Disjunction</strong>: <code>;</code> means logical OR. <code>(a, b ; c)</code> tries <code>a, b</code> first, then <code>c</code>.</li>
<li><strong>Negation as failure</strong>: <code>\+ Goal</code> succeeds when <code>Goal</code> has no solutions. Works with grouped goals: <code>\+ (beat(T, 1) ; beat(T, 3))</code>.</li>
<li><strong>Grouping</strong>: Parentheses change precedence for disjunction/negation and arithmetic.</li>
<li><strong>Infix comparisons</strong>: Use <code>&lt;</code>, <code>&gt;</code>, <code>=&lt;</code>, <code>&gt;=</code>, <code>=:=</code> (numeric equality), <code>=\=</code> (numeric inequality), and <code>=</code> (unification). Examples: <code>T &gt;= 4</code>, <code>Vel =:= 0.8</code>, <code>Note1 = Note2</code>.</li>
<li><strong>Arithmetic expressions</strong>: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> can appear inside arguments and in infix comparisons: <code>Vel = (A + B) / 2</code>, <code>T &lt; 8 - 0.5</code>.</li>
<li><strong>Unification</strong>: <code>=</code> unifies terms (after evaluating arithmetic expressions). It can bind variables or check equality of structures.</li>
<li><strong>Built-ins vs infix</strong>: Comparisons via infix operators replace <code>lt/gt/eq</code> in most cases. List/logic helpers (<code>within/3</code>, <code>distinct/1</code>, <code>cooldown/3</code>, etc.) remain as predicates.</li>
<li><strong>Randomness/state</strong>: <code>prob/1</code>, <code>choose/2</code>, <code>pick/2</code>, <code>rand/3</code>, <code>randint/3</code> add variation. <code>cycle/2</code> and <code>cooldown/3</code> keep state across calls (reset by example change or reload).</li>
<li><strong>Time</strong>: <code>T</code> is in beats. Use <code>beat/2</code>, <code>phase/3</code>, <code>every/2</code>, <code>euc/5</code>, <code>within/3</code> for rhythm. Scheduler swing/lookahead are handled automatically.</li>
<li><strong>Comments</strong>: <code>%</code> starts a line comment (runs to newline).</li>
</ul>
<h2>Troubleshooting</h2>
<ul>
<li>No sound: click the page, press <strong>Start</strong>, ensure device volume, disable mute/silent.</li>
<li>Parse errors: check missing periods or mismatched parens/brackets.</li>
<li>Network/Pages: hard refresh or disable old service workers if a stale cached build interferes.</li>
</ul>
